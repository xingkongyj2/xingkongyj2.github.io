<!DOCTYPE html>




































<html
  class="not-ready text-sm lg:text-base"
  style="--bg: "
  lang="zh"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>Google C&#43;&#43;风格指南 - YJ-Ma&#39;s blog</title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="C&#43;&#43; 风格指南— Google 开源项目风格指南
1. 头文件 1.1 Self-contained 头文件 一个头文件要有#define保护。
.h和.cpp需要各自包含他们所需要的其它头文件。如果.cpp需要的头文件中在.h中存在，那就不必再引入了。
？如果 .h 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 .cc 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。
？例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 .cc 文件里。
存取函数一般内联在头文件中
1.2 头文件保护#define 所有头文件都应该有 #define 保护来防止头文件被多重包含, 命名格式当是: &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_ .
//项目 `foo` 中的头文件 `foo/src/bar/baz.h` #ifndef FOO_BAR_BAZ_H_ #define FOO_BAR_BAZ_H_ ... #endif // FOO_BAR_BAZ_H_ 1.3 前置声明 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。
1.4 内联函数 只有当函数只有 10 行甚至更少时才将其定义为内联函数.
谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!
内联那些包含循环或 switch 语句的函数常常是得不偿失
1.5 #include 的路径及顺序 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C&#43;&#43; 库, 其他库的 .h, 本项目内的 .h." />
  <meta
    name="author"
    content=""
  />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://xingkongyj2.github.io/main.min.css" />

  
  <script
    defer
    src="https://xingkongyj2.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
   
  <link rel="preload" as="image" href="https://xingkongyj2.github.io/theme.png" />

  
  
  
  <link rel="preload" as="image" href="https://www.gravatar.com/avatar/1461c57a55669f50e12c3d2415165ba9?s=160&amp;d=identicon" />
  
  

  
  <link rel="preload" as="image" href="https://xingkongyj2.github.io/github.svg" />
  

  
  <link rel="icon" href="https://xingkongyj2.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://xingkongyj2.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.101.0" />

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="Google C&#43;&#43;风格指南" />
<meta property="og:description" content="C&#43;&#43; 风格指南— Google 开源项目风格指南
1. 头文件 1.1 Self-contained 头文件 一个头文件要有#define保护。
.h和.cpp需要各自包含他们所需要的其它头文件。如果.cpp需要的头文件中在.h中存在，那就不必再引入了。
？如果 .h 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 .cc 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。
？例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 .cc 文件里。
存取函数一般内联在头文件中
1.2 头文件保护#define 所有头文件都应该有 #define 保护来防止头文件被多重包含, 命名格式当是: &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_ .
//项目 `foo` 中的头文件 `foo/src/bar/baz.h` #ifndef FOO_BAR_BAZ_H_ #define FOO_BAR_BAZ_H_ ... #endif // FOO_BAR_BAZ_H_ 1.3 前置声明 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。
1.4 内联函数 只有当函数只有 10 行甚至更少时才将其定义为内联函数.
谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!
内联那些包含循环或 switch 语句的函数常常是得不偿失
1.5 #include 的路径及顺序 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C&#43;&#43; 库, 其他库的 .h, 本项目内的 .h." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xingkongyj2.github.io/post/google-c&#43;&#43;%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-02-13T14:54:24+08:00" />
<meta property="article:modified_time" content="2023-02-13T14:54:24+08:00" />


  
  <meta itemprop="name" content="Google C&#43;&#43;风格指南">
<meta itemprop="description" content="C&#43;&#43; 风格指南— Google 开源项目风格指南
1. 头文件 1.1 Self-contained 头文件 一个头文件要有#define保护。
.h和.cpp需要各自包含他们所需要的其它头文件。如果.cpp需要的头文件中在.h中存在，那就不必再引入了。
？如果 .h 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 .cc 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。
？例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 .cc 文件里。
存取函数一般内联在头文件中
1.2 头文件保护#define 所有头文件都应该有 #define 保护来防止头文件被多重包含, 命名格式当是: &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_ .
//项目 `foo` 中的头文件 `foo/src/bar/baz.h` #ifndef FOO_BAR_BAZ_H_ #define FOO_BAR_BAZ_H_ ... #endif // FOO_BAR_BAZ_H_ 1.3 前置声明 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。
1.4 内联函数 只有当函数只有 10 行甚至更少时才将其定义为内联函数.
谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!
内联那些包含循环或 switch 语句的函数常常是得不偿失
1.5 #include 的路径及顺序 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C&#43;&#43; 库, 其他库的 .h, 本项目内的 .h."><meta itemprop="datePublished" content="2023-02-13T14:54:24+08:00" />
<meta itemprop="dateModified" content="2023-02-13T14:54:24+08:00" />
<meta itemprop="wordCount" content="3310">
<meta itemprop="keywords" content="读书笔记," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Google C&#43;&#43;风格指南"/>
<meta name="twitter:description" content="C&#43;&#43; 风格指南— Google 开源项目风格指南
1. 头文件 1.1 Self-contained 头文件 一个头文件要有#define保护。
.h和.cpp需要各自包含他们所需要的其它头文件。如果.cpp需要的头文件中在.h中存在，那就不必再引入了。
？如果 .h 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 .cc 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。
？例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 .cc 文件里。
存取函数一般内联在头文件中
1.2 头文件保护#define 所有头文件都应该有 #define 保护来防止头文件被多重包含, 命名格式当是: &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_ .
//项目 `foo` 中的头文件 `foo/src/bar/baz.h` #ifndef FOO_BAR_BAZ_H_ #define FOO_BAR_BAZ_H_ ... #endif // FOO_BAR_BAZ_H_ 1.3 前置声明 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。
1.4 内联函数 只有当函数只有 10 行甚至更少时才将其定义为内联函数.
谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!
内联那些包含循环或 switch 语句的函数常常是得不偿失
1.5 #include 的路径及顺序 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C&#43;&#43; 库, 其他库的 .h, 本项目内的 .h."/>

  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    
    <a
      class="btn-dark h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"
    ></a>
  </div>

  <a
    class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
  ></a>

  
  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = ` null `.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    
    <nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6">
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/"
        >Home</a
      >
      
    </nav>
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/xingkongyj2"
        target="_blank"
        rel="me"
      ></a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"
    >
      

<article>
  <header class="mb-20 custom-post-title">
    <h1 class="!my-0 pb-2.5">Google C&#43;&#43;风格指南</h1>

    
    <div class="text-sm opacity-60">
      
      <time>2023年2月13日</time>
      
      
    </div>
    
  </header>

  <section><p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/">C++ 风格指南— Google 开源项目风格指南</a></p>
<h1 id="1-头文件">1. 头文件</h1>
<h3 id="11-self-contained-头文件">1.1 Self-contained 头文件</h3>
<p>一个头文件要有#define保护。</p>
<p>.h和.cpp需要各自包含他们所需要的其它头文件。如果.cpp需要的头文件中在.h中存在，那就不必再引入了。</p>
<p>？如果 <code>.h</code> 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 <code>.cc</code> 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。</p>
<p>？例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 <code>.cc</code> 文件里。</p>
<p>存取函数一般内联在头文件中</p>
<h3 id="12-头文件保护define">1.2 头文件保护#define</h3>
<p>所有头文件都应该有 <code>#define</code> 保护来防止头文件被多重包含, 命名格式当是: <code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</code> .</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//项目 `foo` 中的头文件 `foo/src/bar/baz.h`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifndef FOO_BAR_BAZ_H_
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define FOO_BAR_BAZ_H_
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>...
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">// FOO_BAR_BAZ_H_
</span></span></span></code></pre></div><h3 id="13-前置声明">1.3 前置声明</h3>
<p>尽可能地避免使用前置声明。使用 <code>#include</code> 包含需要的头文件即可。</p>
<h3 id="14-内联函数">1.4 内联函数</h3>
<p>只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p>
<p>谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p>
<p>内联那些包含循环或 <code>switch</code> 语句的函数常常是得不偿失</p>
<h3 id="15-include-的路径及顺序">1.5 <code>#include</code> 的路径及顺序</h3>
<p>使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h.</p>
<p>项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 <code>.</code> (当前目录) 或 <code>..</code> (上级目录). 例如, <code>google-awesome-project/src/base/logging.h</code> 应该按如下方式包含:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;base/logging.h&#34;</span><span style="color:#75715e">
</span></span></span></code></pre></div><p><code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的主要作用是实现或测试 <code>dir2/foo2.h</code> 的功能, <code>foo.cc</code> 中包含头文件的次序如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ae81ff">1.</span>  dir2<span style="color:#f92672">/</span>foo2.h (<span style="color:#960050;background-color:#1e0010">优先位置</span>, <span style="color:#960050;background-color:#1e0010">详情如下</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2.</span>  C <span style="color:#960050;background-color:#1e0010">系统文件</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3.</span>  C<span style="color:#f92672">++</span> <span style="color:#960050;background-color:#1e0010">系统文件</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4.</span>  <span style="color:#960050;background-color:#1e0010">其他库的</span> <span style="color:#960050;background-color:#1e0010">`</span>.h<span style="color:#960050;background-color:#1e0010">`</span> <span style="color:#960050;background-color:#1e0010">文件</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5.</span>  <span style="color:#960050;background-color:#1e0010">本项目内</span> <span style="color:#960050;background-color:#1e0010">`</span>.h<span style="color:#960050;background-color:#1e0010">`</span> <span style="color:#960050;background-color:#1e0010">文件</span>
</span></span></code></pre></div><p>这种优先的顺序排序保证当 <code>dir2/foo2.h</code> 遗漏某些必要的库时， <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的构建会立刻中止。因此这一条规则保证维护这个库的人首先看到本库的错误，而不是先看到其他库的错误。</p>
<p>要用到 <code>bar.h</code> 中的某个符号, 哪怕所包含的 <code>foo.h</code> 已经包含了 <code>bar.h</code>, 也照样得包含 <code>bar.h</code>, 除非 <code>foo.h</code> 有明确说明它会自动向您提供 <code>bar.h</code> 中的 symbol. 不过，如果.h对应的cc文件所需要的头文件已经在.h包含的，就不用再重复包含进其 cc 文件里面了，就像 <code>foo.cc</code> 只包含 <code>foo.h</code> 就够了。</p>
<p>举例来说, <code>google-awesome-project/src/foo/internal/fooserver.cc</code> 的包含次序如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>#include &#34;foo/public/fooserver.h&#34; // 优先位置
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#include &lt;sys/types.h&gt;
</span></span><span style="display:flex;"><span>#include &lt;unistd.h&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#include &lt;hash_map&gt;
</span></span><span style="display:flex;"><span>#include &lt;vector&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#include &#34;base/basictypes.h&#34;
</span></span><span style="display:flex;"><span>#include &#34;base/commandlineflags.h&#34;
</span></span><span style="display:flex;"><span>#include &#34;foo/public/bar.h&#34;
</span></span></code></pre></div><h1 id="2-作用域">2. 作用域</h1>
<h3 id="21命名空间">2.1命名空间</h3>
<p>命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突</p>
<p>内联命名空间会自动把内部的标识符放到外层作用域，比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>namespace X {
</span></span><span style="display:flex;"><span>inline namespace Y {
</span></span><span style="display:flex;"><span>void foo();
</span></span><span style="display:flex;"><span>}  // namespace Y
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>X::Y::foo()</code> 与 <code>X::foo()</code> 彼此可代替。</p>
<p>遵守 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/naming.html#namespace-names">命名空间命名</a> 中的规则。</p>
<p>在命名空间的最后注释出命名空间的名字。</p>
<p>用命名空间把文件包含, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它命名空间：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>// .h 文件
</span></span><span style="display:flex;"><span>namespace mynamespace {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 所有声明都置于命名空间中
</span></span><span style="display:flex;"><span>// 注意不要使用缩进
</span></span><span style="display:flex;"><span>class MyClass {
</span></span><span style="display:flex;"><span>    public:
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    void Foo();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} // namespace mynamespace
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>// .cc 文件
</span></span><span style="display:flex;"><span>namespace mynamespace {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 函数定义都置于命名空间中
</span></span><span style="display:flex;"><span>void MyClass::Foo() {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} // namespace mynamespace
</span></span></code></pre></div><p>不应该使用 <em>using 指示</em> 引入整个命名空间的标识符号。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>// 禁止 —— 污染命名空间
</span></span><span style="display:flex;"><span>using namespace foo;
</span></span></code></pre></div><p>禁止用内联命名空间</p>
<h3 id="22-匿名命名空间和静态变量">2.2 匿名命名空间和静态变量</h3>
<p>在 <code>.cc</code> 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 <code>static</code> 。但是不要在 <code>.h</code> 文件中这么做。</p>
<p>所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为 <code>static</code> 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</p>
<p>推荐、鼓励在 <code>.cc</code> 中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在 <code>.h</code> 中使用。</p>
<p>匿名命名空间的声明和具名的格式相同，在最后注释上 <code>namespace</code> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>namespace {
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>}  // namespace
</span></span></code></pre></div><h3 id="23-非成员函数静态成员函数和全局函数">2.3 非成员函数、静态成员函数和全局函数</h3>
<p>使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.</p>
<p>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/#namespaces">2.1. 命名空间</a> 。举例而言，对于头文件 <code>myproject/foo_bar.h</code> , 应当使用:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>namespace myproject {
</span></span><span style="display:flex;"><span>namespace foo_bar {
</span></span><span style="display:flex;"><span>void Function1();
</span></span><span style="display:flex;"><span>void Function2();
</span></span><span style="display:flex;"><span>}  // namespace foo_bar
</span></span><span style="display:flex;"><span>}  // namespace myproject
</span></span></code></pre></div><p>而不是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>namespace myproject {
</span></span><span style="display:flex;"><span>class FooBar {
</span></span><span style="display:flex;"><span> public:
</span></span><span style="display:flex;"><span>  static void Function1();
</span></span><span style="display:flex;"><span>  static void Function2();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>}  // namespace myproject
</span></span></code></pre></div><p>定义在同一编译单元的函数, 被其他<em>编译单元</em>直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的命名空间内.</p>
<p>如果你必须定义非成员函数, 又只是在 <code>.cc</code> 文件中使用它, 可使用匿名 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/#namespaces">2.1. 命名空间</a> 或 <code>static</code> 链接关键字 (如 <code>static int Foo() {...}</code>) 限定其作用域.</p>
<h3 id="24-局部变量">2.4 局部变量</h3>
<p>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</p>
<p>C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值, 比如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>int i;
</span></span><span style="display:flex;"><span>i = f(); // 坏——初始化和声明分离
</span></span><span style="display:flex;"><span>int j = g(); // 好——初始化时声明
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector&lt;int&gt; v;
</span></span><span style="display:flex;"><span>v.push_back(1); // 用花括号初始化更好
</span></span><span style="display:flex;"><span>v.push_back(2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector&lt;int&gt; v = {1, 2}; // 好——v 一开始就初始化
</span></span></code></pre></div><p>即：声明-定义-初始化一体化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低.
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>// 低效的实现
</span></span><span style="display:flex;"><span>for (int i = 0; i &lt; 1000000; ++i) {
</span></span><span style="display:flex;"><span>    Foo f;                  // 构造函数和析构函数分别调用 1000000 次!
</span></span><span style="display:flex;"><span>    f.DoSomething(i);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 构造函数和析构函数只调用 1 次
</span></span><span style="display:flex;"><span>Foo f; 
</span></span><span style="display:flex;"><span>for (int i = 0; i &lt; 1000000; ++i) {
</span></span><span style="display:flex;"><span>    f.DoSomething(i);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>for中的局部变量，遍历一次后，就会消亡。下次循环会重新定义变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>#include &lt;iostream&gt;  
</span></span><span style="display:flex;"><span>#include &lt;vector&gt;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>class Test{  
</span></span><span style="display:flex;"><span>public:  
</span></span><span style="display:flex;"><span>    Test(){std::cout&lt;&lt;&#34;构造函数&#34;&lt;&lt;std::endl;}  
</span></span><span style="display:flex;"><span>    ~Test(){std::cout&lt;&lt;&#34;析构函数&#34;&lt;&lt;std::endl;}  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>int main() {  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    for(int i=0;i&lt;10;i++)  
</span></span><span style="display:flex;"><span>    {  
</span></span><span style="display:flex;"><span>        Test test;  
</span></span><span style="display:flex;"><span>        std::cout&lt;&lt;&amp;test&lt;&lt;std::endl;  
</span></span><span style="display:flex;"><span>        int a=0;  
</span></span><span style="display:flex;"><span>        std::cout&lt;&lt;&amp;a&lt;&lt;std::endl;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    return 0;  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="25-静态和全局变量">2.5 静态和全局变量</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。
</span></span></code></pre></div><p>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。</p>
<p>静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug. 所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数（比如<code>getenv()</code> <em>或</em> <code>getpid()</code>）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为 (unspecified behaviour)。
</span></span></code></pre></div><p>只允许 POD 类型的静态变量，不能定义类类型的全局或静态变量。即完全禁用 vector (使用 C 数组替代) 和 string (使用 const char[])。</p>
<p>总结：</p>
<ol>
<li>
<p><code>cc</code> 中的匿名命名空间可避免命名冲突, 限定作用域, 避免直接使用 <code>using</code> 关键字污染命名空间;</p>
</li>
<li>
<p>嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 <code>public</code>;</p>
</li>
<li>
<p>尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;</p>
</li>
<li>
<p>多线程中的全局变量 (含静态成员变量) 不要使用 <code>class</code> 类型 (含 STL 容器), 避免不明确行为导致的 bug.</p>
</li>
<li>
<p>作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合, 提高编译/执行效率.</p>
</li>
</ol>
<h1 id="3-类">3. 类</h1>
<h3 id="31-构造函数的职责">3.1. 构造函数的职责</h3>
<p>不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p>
<p>如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.</p>
<p>构造函数的地址是无法被取得的, 因此, 举例来说, 由构造函数完成的工作是无法以简单的方式交给其他线程的.</p>
<p>构造函数不允许调用虚函数. 如果代码允许, 直接终止程序是一个合适的处理错误的方式. 否则, 考虑用 <code>Init()</code> 方法或工厂函数.</p>
<h3 id="32-隐式类型转换">3.2. 隐式类型转换</h3>
<p>不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 <code>explicit</code> 关键字.</p>
<p><code>explicit</code> 关键字可以用于构造函数或 (在 C++11 引入) 类型转换运算符, 以保证只有当目的类型在调用点被显式写明时才能进行类型转换。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>class Foo {
</span></span><span style="display:flex;"><span>  explicit Foo(int x, double y);
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>void Func(Foo f);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>此时下面的代码是不允许的:
</span></span><span style="display:flex;"><span>Func({42, 3.14});  // Error
</span></span></code></pre></div><p>隐式类型转换会隐藏类型不匹配的错误. 有时, 目的类型并不符合用户的期望, 甚至用户根本没有意识到发生了类型转换.</p>
<p>隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候, 因为这时很难判断到底是哪个函数被调用.</p>
<p>单参数构造函数有可能会被无意地用作隐式类型转换</p>
<p>不能以一个参数进行调用的构造函数不应当加上 <code>explicit</code>.</p>
<p>接受一个 <code>std::initializer_list</code> 作为参数的构造函数也应当省略 <code>explicit</code>, 以便支持拷贝初始化 (例如 <code>MyType m = {1, 2};</code>).</p>
<h3 id="33-可拷贝类型和可移动类型">3.3. 可拷贝类型和可移动类型</h3>
<p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p>
<p>如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可移动, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作.</p>
<p>如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>class Foo {
</span></span><span style="display:flex;"><span> public:
</span></span><span style="display:flex;"><span>  Foo(Foo&amp;&amp; other) : field_(other.field) {}
</span></span><span style="display:flex;"><span>  // 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> private:
</span></span><span style="display:flex;"><span>  Field field_;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个 <code>public virtual Clone()</code> 和一个 <code>protected</code> 的拷贝构造函数以供派生类实现.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>如果你的类不需要拷贝 / 移动操作, 请显式地通过在 `public` 域中使用 `= delete` 或其他手段禁用之.
</span></span></code></pre></div><h3 id="34-结构体-vs-类">3.4. 结构体 VS. 类</h3>
<p>仅当只有数据成员时使用 <code>struct</code>, 其它一概使用 <code>class</code>.</p>
<h3 id="35-继承">3.5. 继承</h3>
<p>使用组合 (注: 这一点也是GoF在Design Patterns里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承.</p>
<p>当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承, 子类继承父类的实现代码; 接口继承, 子类仅继承父类的方法名称.</p>
<p>必要的话, 析构函数声明为 <code>virtual</code>. 如果你的类有虚函数, 则析构函数也应该为虚函数.</p>
<p>对于可能被子类访问的成员函数, 不要过度使用 <code>protected</code> 关键字. 注意, 数据成员都必须是私有的。</p>
<p>对于重载的虚函数或虚析构函数, 使用 override</p>
<h3 id="36-接口">3.6. 接口</h3>
<p>当一个类满足以下要求时, 称之为纯接口:</p>
<ul>
<li>
<p>只有纯虚函数 (”<code>=0</code>”) 和静态函数 (除了下文提到的析构函数).</p>
</li>
<li>
<p>没有非静态数据成员.</p>
</li>
<li>
<p>没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 <code>protected</code>.</p>
</li>
<li>
<p>如果它是一个子类, 也只能从满足上述条件并以 <code>Interface</code> 为后缀的类继承.</p>
</li>
</ul>
<p>接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数 (作为上述第 1 条规则的特例, 析构函数不能是纯虚函数)</p>
<h3 id="37-运算符重载">3.7. 运算符重载</h3>
<p>除少数特定环境外, 不要重载运算符.</p>
<p>只有在意义明显, 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符. 例如, <code>|</code> 要作为位或或逻辑或来使用, 而不是作为 shell 中的管道.</p>
<h3 id="38-声明顺序">3.8. 声明顺序</h3>
<p>将相似的声明放在一起, 将 <code>public</code> 部分放在最前.</p>
<p>类定义一般应以 <code>public:</code> 开始, 后跟 <code>protected:</code>, 最后是 <code>private:</code>. 省略空部分.</p>
<p>在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 <code>typedef</code>, <code>using</code> 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员.</p>
<h1 id="4-函数">4. 函数</h1>
<h3 id="41-输入和输出">4.1. 输入和输出</h3>
<p>倾向于按值返回， 否则按引用返回。 避免返回指针</p>
<h3 id="42-编写简短函数">4.2. 编写简短函数</h3>
<p>如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p>
<h3 id="43-引用参数">4.3. 引用参数</h3>
<p>所有按引用传递的参数必须加上 <code>const</code>.</p>
<p>输入参数是值参或 <code>const</code> 引用, 传出参数为指针。输入参数可以是 <code>const</code> 指针, 但决不能是非 <code>const</code> 的引用参数, 除非特殊要求, 比如 <code>swap()</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>void Foo(const string &amp;in, string *out);
</span></span></code></pre></div><h3 id="44-函数重载">4.4. 函数重载</h3>
<p>如果打算重载一个函数, 可以试试改在函数名里加上参数信息.避免大量的重载函数。例如, 用 <code>AppendString()</code> 和 <code>AppendInt()</code> 等, 而不是一口气重载多个 <code>Append()</code>.</p>
<h3 id="45-缺省参数">4.5. 缺省参数</h3>
<p>只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致.</p>
<p>一般情况下建议使用函数重载</p>
<p>缺省参数会干扰函数指针, 导致函数签名与调用点的签名不一致. 而函数重载不会导致这样的问题.</p>
<p>对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像 <code>void f(int n = counter++);</code> 这样的代码.)</p>
<h3 id="46-函数返回类型后置语法">4.6. 函数返回类型后置语法</h3>
<p>在大部分情况下, 应当继续使用以往的函数声明写法, 即将返回类型置于函数名前. 只有在必需的时候 (如 Lambda 表达式) 或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法. 但是后一种情况一般来说是很少见的, 大部分时候都出现在相当复杂的模板代码中, 而多数情况下不鼓励写这样 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#template-metaprogramming">复杂的模板代码</a>.</p>
<h1 id="5-google-的奇技">5. Google 的奇技</h1>
<h3 id="51-所有权与智能指针">5.1. 所有权与智能指针</h3>
<p>动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.</p>
<p>如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用 <code>std::unique_ptr</code> 来明确所有权传递。如果没有很好的理由, 则不要使用共享所有权. 这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显, 并且操作的对象是不可变的（比如说 <code>std::shared_ptr&lt;const Foo&gt;</code> ）时候, 才能这么做. 如果确实要使用共享所有权, 建议于使用 <code>std::shared_ptr</code> .</p>
<h3 id="52-cpplint">5.2. Cpplint</h3>
<p><code>cpplint.py</code> 是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍然是一个非常有用的工具. 在行尾加 <code>// NOLINT</code>, 或在上一行加 <code>// NOLINTNEXTLINE</code>, 可以忽略报错.</p>
<h1 id="6-其他-c-特性">6. 其他 C++ 特性</h1>
<h3 id="62-右值引用">6.2. 右值引用</h3>
<p>只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用std::forward</p>
<h3 id="63-函数重载">6.3. 函数重载</h3>
<p>若要用好函数重载，最好能让读者一看调用点就胸有成竹，不用花心思猜测调用的重载函数到底是哪一种。该规则适用于构造函数。</p>
<p>如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用 AppendString() 和 AppendInt() 等， 而不是一口气重载多个 Append().</p>
<h3 id="64-缺省参数">6.4. 缺省参数</h3>
<p>我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。</p>
<p>缺省参数会干扰函数指针，害得后者的函数签名（function signature）往往对不上所实际要调用的函数签名。即在一个现有函数添加缺省参数，就会改变它的类型，那么调用其地址的代码可能会出错，不过函数重载就没这问题了。</p>
<p>「缺省参数」只会出现在函数定义里。</p>
<p>除了以下情况，我们要求必须显式提供所有参数</p>
<ul>
<li>
<p>位于 <code>.cc</code> 文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了。</p>
</li>
<li>
<p>可以在构造函数里用缺省参数，毕竟不可能取得它们的地址。</p>
</li>
</ul>
<h3 id="65-变长数组和-alloca">6.5. 变长数组和 alloca</h3>
<p>我们不允许使用变长数组和 <code>alloca()</code>.</p>
<p>改用更安全的分配器（allocator），就像<code>std::vector</code> 或 <code>std::unique_ptr&lt;T[]&gt;</code></p>
<h3 id="66-友元">6.6. 友元</h3>
<p>允许合理的使用友元类及友元函数.</p>
<p>通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类. 经常用到友元的一个地方是将 <code>FooBuilder</code> 声明为 <code>Foo</code> 的友元, 以便 <code>FooBuilder</code> 正确构造 <code>Foo</code> 的内部状态, 而无需将该状态暴露出来. 某些情况下, 将一个单元测试类声明成待测类的友元会很方便.</p>
<h3 id="67-异常">6.7. 异常</h3>
<p>不使用 C++ 异常.</p>
<h3 id="68-运行时类型识别">6.8. 运行时类型识别</h3>
<p>禁止使用 RTTI.</p>
<p>因为不知道基类指针指向基类还是派生类，所以可以用dynamic_cast转换后的成功或者失败来判断指针指向的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>bool Base::Equal(Base* other) = 0;
</span></span><span style="display:flex;"><span>bool Derived::Equal(Base* other) {
</span></span><span style="display:flex;"><span>  Derived* that = dynamic_cast&lt;Derived*&gt;(other);
</span></span><span style="display:flex;"><span>  if (that == NULL)
</span></span><span style="display:flex;"><span>    return false;
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在运行时判断类型通常意味着设计问题. 如果你需要在运行期间确定一个对象的类型, 这通常说明你需要考虑重新设计你的类.</p>
<p>RTTI 有合理的用途但是容易被滥用, 因此在使用时请务必注意. 在单元测试中可以使用 RTTI, 但是在其他代码中请尽量避免. 尤其是在新代码中, 使用 RTTI 前务必三思. 如果你的代码需要根据不同的对象类型执行不同的行为的话, 请考虑用以下的两种替代方案之一查询类型:</p>
<ul>
<li>
<p>如果这一工作需要在对象之外完成, 可以考虑使用双重分发的方案, 例如使用访问者设计模式. 这就能够在对象之外进行类型判断.</p>
</li>
<li>
<p>如果程序能够保证给定的基类实例实际上都是某个派生类的实例, 那么就可以自由使用 dynamic_cast. 在这种情况下, 使用 dynamic_cast 也是一种替代方案.</p>
</li>
</ul>
<p>不要像下面这样:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>if (typeid(*data) == typeid(D1)) {
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>} else if (typeid(*data) == typeid(D2)) {
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>} else if (typeid(*data) == typeid(D3)) {
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且, 一旦某个子类的属性改变了, 你很难找到并修改所有受影响的代码块.</p>
<h3 id="69-类型转换">6.9. 类型转换</h3>
<p>使用 C++ 的类型转换, 如 <code>static_cast&lt;&gt;()</code>. 不要使用 <code>int y = (int)x</code> 或 <code>int y = int(x)</code> 等转换方式</p>
<p>用 <code>static_cast</code> 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.</p>
<p>用 <code>const_cast</code> 去掉 <code>const</code> 限定符.</p>
<p>用 <code>reinterpret_cast</code> 指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用.</p>
<h3 id="610-流">6.10. 流</h3>
<p>流：cout等</p>
<p>格式化：<code>printf</code></p>
<p>唯一性原则 (Only One Way): 我们希望在任何时候都只使用一种确定的 I/O 类型, 使代码在所有 I/O 处都保持一致</p>
<p>只在记录日志时使用流.流用来替代 <code>printf()</code> 和 <code>scanf()</code>.</p>
<p>不要使用流, 除非是日志接口需要. 使用 <code>printf</code> 之类的代替.</p>
<p>使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.</p>
<p>流最大的优势是在输出时不需要关心打印对象的类型. 这是一个亮点. 同时, 也是一个不足: 你很容易用错类型, 而编译器不会报警. 使用流时容易造成的这类错误:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>cout &lt;&lt; this;   // 输出地址
</span></span><span style="display:flex;"><span>cout &lt;&lt; *this;  // 输出值
</span></span></code></pre></div><p>流与格式化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>cerr &lt;&lt; &#34;Error connecting to &#39;&#34; &lt;&lt; foo-&gt;bar()-&gt;hostname.first
</span></span><span style="display:flex;"><span>     &lt;&lt; &#34;:&#34; &lt;&lt; foo-&gt;bar()-&gt;hostname.second &lt;&lt; &#34;: &#34; &lt;&lt; strerror(errno);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fprintf(stderr, &#34;Error connecting to &#39;%s:%u: %s&#34;,
</span></span><span style="display:flex;"><span>        foo-&gt;bar()-&gt;hostname.first, foo-&gt;bar()-&gt;hostname.second,
</span></span><span style="display:flex;"><span>        strerror(errno));
</span></span></code></pre></div><p>采用 <code>printf + read/write</code>。</p>
<h3 id="611-前置自增和自减">6.11. 前置自增和自减</h3>
<p>对于迭代器和其他模板对象使用前缀形式 (<code>++i</code>) 的自增, 自减运算符.</p>
<p>对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).</p>
<h3 id="612-const-用法">6.12. <code>const</code> 用法</h3>
<p>建议在任何可能的情况下都要使用 <code>const</code>. 此外有时改用 C++11 推出的 constexpr 更好：</p>
<ul>
<li>
<p>如果函数不会修改你传入的引用或指针类型参数, 该参数应声明为 <code>const</code></p>
</li>
<li>
<p>不会修改数据成员的函数应该声明成 <code>const</code>.</p>
</li>
</ul>
<p><code>const</code> 是入侵性的: 如果你向一个函数传入 <code>const</code> 变量, 函数原型声明中也必须对应 <code>const</code> 参数 (否则变量需要 <code>const_cast</code> 类型转换), 在调用库函数时显得尤其麻烦.</p>
<p>如果数据成员在对象构造之后不再发生变化, 可将其定义为 <code>const</code>.</p>
<p>关键字 <code>mutable</code> 可以使用, 但是在多线程中是不安全的, 使用时首先要考虑线程安全.</p>
<p><code>int const *foo</code> 形式, 不喜欢 <code>const int* foo</code>，将 <code>const</code> 放在前面才更易读.</p>
<h3 id="613-constexpr-用法">6.13. <code>constexpr</code> 用法</h3>
<p>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p>
<p>靠 constexpr 特性，方才实现了 C++ 在接口上打造真正常量机制的可能。好好用 constexpr 来定义真・常量以及支持常量的函数。避免复杂的函数定义，以使其能够与constexpr一起使用。 千万别痴心妄想地想靠 constexpr 来强制代码「内联」。</p>
<h3 id="614-整型">6.14. 整型</h3>
<p>C++ 内建整型中, 仅使用 <code>int</code>. 如果程序中需要不同大小的变量, 可以使用 <code>&lt;stdint.h&gt;</code> 中长度精确的整型, 如 <code>int16_t</code>.如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如 <code>int64_t</code>. 此外要留意，哪怕您的值并不会超出 int 所能够表示的范围，在计算过程中也可能会溢出。所以拿不准时，干脆用更大的类型。</p>
<pre tabindex="0"><code>&lt;stdint.h&gt;` 定义了 `int16_t`, `uint32_t`, `int64_t` 等整型, 在需要确保整型大小时可以使用它们代替 `short`, `unsigned long long` 等. 在 C 整型中, 只使用 `int`. 在合适的情况下, 推荐使用标准类型如 `size_t` 和 `ptrdiff_t
</code></pre><p>不要使用 <code>uint32_t</code> 等无符号整型, 除非你是在表示一个位组而不是一个数值, 或是你需要定义二进制补码溢出. 尤其是不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.</p>
<p>小心整型类型转换和整型提升（acgtyrant 注：integer promotions, 比如 <code>int</code> 与 <code>unsigned int</code> 运算时，前者被提升为 <code>unsigned int</code> 而有可能溢出），总有意想不到的后果。</p>
<p>在 C 语言中, 这一优点被由其导致的 bug 所淹没. 看看下面的例子:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>for (unsigned int i = foo.Length()-1; i &gt;= 0; --i) ...
</span></span></code></pre></div><p>上述循环永远不会退出! 有时 gcc 会发现该 bug 并报警, 但大部分情况下都不会. 类似的 bug 还会出现在比较有符合变量和无符号变量时. 主要是 C 的类型提升机制会致使无符号类型的行为出乎你的意料.</p>
<p>因此, 使用断言来指出变量为非负数, 而不是使用无符号型!</p>
<h3 id="615-64-位下的可移植性">6.15. 64 位下的可移植性</h3>
<p>代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记.</p>
<p>看不懂，待补充。</p>
<h3 id="616-预处理宏">6.16. 预处理宏</h3>
<p>不要使用宏。使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.</p>
<h3 id="617-0-nullptr-和-null">6.17. 0, <code>nullptr</code> 和 <code>NULL</code></h3>
<p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 指针用 <code>nullptr</code> 或 <code>NULL</code>, 字符 (串) 用 <code>'\0'</code>.</p>
<h3 id="618-sizeof">6.18. sizeof</h3>
<p>尽可能用 <code>sizeof(varname)</code> 代替 <code>sizeof(type)</code>.</p>
<p>使用 <code>sizeof(varname)</code> 是因为当代码中变量类型改变时会自动更新. 您或许会用 <code>sizeof(type)</code> 处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> v;
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> s1 <span style="color:#f92672">=</span> v[<span style="color:#ae81ff">0</span>];  <span style="color:#75715e">// 创建一份 v[0] 的拷贝。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> s2 <span style="color:#f92672">=</span> v[<span style="color:#ae81ff">0</span>];  <span style="color:#75715e">// s2 是 v[0] 的一个引用。
</span></span></span></code></pre></div><h3 id="619-auto">6.19. auto</h3>
<p>用 <code>auto</code> 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。</p>
<p><code>auto</code> 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化 <code>auto</code> 变量。</p>
<p><code>auto</code> 还可以和 C++11 特性「尾置返回类型（trailing return type）」一起用，不过后者只能用在 lambda 表达式里。</p>
<h3 id="620-列表初始化">6.20. 列表初始化</h3>
<p>用列表初始化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>/ Vector 接收了一个初始化列表。任选其一。
</span></span><span style="display:flex;"><span>vector&lt;string&gt; v{&#34;foo&#34;, &#34;bar&#34;};
</span></span><span style="display:flex;"><span>vector&lt;string&gt; v = {&#34;foo&#34;, &#34;bar&#34;};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 可以配合 new 一起用。
</span></span><span style="display:flex;"><span>auto p = new vector&lt;string&gt;{&#34;foo&#34;, &#34;bar&#34;};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// map 接收了一些 pair, 列表初始化大显神威。
</span></span><span style="display:flex;"><span>map&lt;int, string&gt; m = {{1, &#34;one&#34;}, {2, &#34;2&#34;}};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 初始化列表也可以用在返回类型上的隐式转换。
</span></span><span style="display:flex;"><span>vector&lt;int&gt; test_function() { return {1, 2, 3}; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 初始化列表可迭代。
</span></span><span style="display:flex;"><span>for (int i : {-1, -2, -3}) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 在函数调用里用列表初始化。
</span></span><span style="display:flex;"><span>void TestFunction2(vector&lt;int&gt; v) {}
</span></span><span style="display:flex;"><span>TestFunction2({1, 2, 3});
</span></span></code></pre></div><p>用户自定义类型也可以定义接收 <code>std::initializer_list&lt;T&gt;</code> 的构造函数和赋值运算符，以自动列表初始化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>class MyType {
</span></span><span style="display:flex;"><span> public:
</span></span><span style="display:flex;"><span>  // std::initializer_list 专门接收 init 列表。
</span></span><span style="display:flex;"><span>  // 得以值传递。
</span></span><span style="display:flex;"><span>  MyType(std::initializer_list&lt;int&gt; init_list) {
</span></span><span style="display:flex;"><span>    for (int i : init_list) append(i);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  MyType&amp; operator=(std::initializer_list&lt;int&gt; init_list) {
</span></span><span style="display:flex;"><span>    clear();
</span></span><span style="display:flex;"><span>    for (int i : init_list) append(i);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>MyType m{2, 3, 5, 7};
</span></span></code></pre></div><p>列表初始化也适用于常规数据类型的构造，哪怕没有接收 <code>std::initializer_list&lt;T&gt;</code> 的构造函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>double d{1.23};
</span></span><span style="display:flex;"><span>// MyOtherType 没有 std::initializer_list 构造函数，
</span></span><span style="display:flex;"><span> // 直接上接收常规类型的构造函数。
</span></span><span style="display:flex;"><span>class MyOtherType {
</span></span><span style="display:flex;"><span> public:
</span></span><span style="display:flex;"><span>  explicit MyOtherType(string);
</span></span><span style="display:flex;"><span>  MyOtherType(int, string);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>MyOtherType m = {1, &#34;b&#34;};
</span></span><span style="display:flex;"><span>// 不过如果构造函数是显式的（explict），您就不能用 `= {}` 了。
</span></span><span style="display:flex;"><span>MyOtherType m{&#34;b&#34;};
</span></span></code></pre></div><p>千万别直接列表初始化 auto 变量，看下一句，估计没人看得懂：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>auto d = {1.23};        // d 即是 std::initializer_list&lt;double&gt;
</span></span><span style="display:flex;"><span>auto d = double{1.23};  // 善哉 -- d 即为 double, 并非 std::initializer_list.
</span></span></code></pre></div><h3 id="621-lambda-表达式">6.21. Lambda 表达式</h3>
<p>适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。</p>
<p>Lambda 表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>std::sort(v.begin(), v.end(), [](int x, int y) {
</span></span><span style="display:flex;"><span>    return Weight(x) &lt; Weight(y);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>禁用默认捕获，捕获都要显式写出来。打比方，比起 <code>[=](int x) {return x + n;}</code>, 您该写成 <code>[n](int x) {return x + n;}</code> 才对，这样读者也好一眼看出 <code>n</code> 是被捕获的值。</p>
<p>匿名函数始终要简短，如果函数体超过了五行，那么还不如起名（acgtyrant 注：即把 lambda 表达式赋值给对象），或改用函数。</p>
<p>如果可读性更好，就显式写出 lambd 的尾置返回类型，就像auto.</p>
<h3 id="622-模板编程">6.22. 模板编程</h3>
<p>不要使用复杂的模板编程</p>
<h3 id="623-boost-库">6.23. Boost 库</h3>
<p>只使用 Boost 中被认可的库.</p>
<h3 id="小结">小结</h3>
<p>实际上，<a href="http://www.zhihu.com/question/24439516/answer/27858964">缺省参数会改变函数签名的前提是改变了它接收的参数数量</a>，比如把 <code>void a()</code> 改成 <code>void a(int b = 0)</code>, 开发者改变其代码的初衷也许是，在不改变「代码兼容性」的同时，又提供了可选 int 参数的余地，然而这终究会破坏函数指针上的兼容性，毕竟函数签名确实变了。</p>
<p>把自带缺省参数的函数地址赋值给指针时，会丢失缺省参数信息。、</p>
<p><a href="https://www.zhihu.com/question/22889420">对使用 C++ 异常处理应具有怎样的态度？ - 知乎</a></p>
<h1 id="7命名约定">7.命名约定</h1>
<p>最重要的一致性规则是命名管理.</p>
<h3 id="71-通用命名规则">7.1. 通用命名规则</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>int price_count_reader;    // 无缩写
</span></span><span style="display:flex;"><span>int num_errors;            // &#34;num&#34; 是一个常见的写法
</span></span><span style="display:flex;"><span>int num_dns_connections;   // 人人都知道 &#34;DNS&#34; 是什么
</span></span></code></pre></div><p>注意, 一些特定的广为人知的缩写是允许的, 例如用 <code>i</code> 表示迭代变量和用 <code>T</code> 表示模板参数.</p>
<h3 id="72-文件命名">7.2. 文件命名</h3>
<p>文件名要全部小写, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>), 依照项目的约定. 如果没有约定, 那么 “<code>_</code>” 更好.</p>
<p>可接受的文件命名示例:</p>
<ul>
<li>
<p><code>my_useful_class.cc</code></p>
</li>
<li>
<p><code>my-useful-class.cc</code></p>
</li>
<li>
<p><code>myusefulclass.cc</code></p>
</li>
</ul>
<p>不要使用已经存在于 <code>/usr/include</code> 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如 <code>db.h</code>.</p>
<p>通常应尽量让文件名更加明确. <code>http_server_logs.h</code> 就比 <code>logs.h</code> 要好. 定义类时文件名一般成对出现, 如 <code>foo_bar.h</code> 和 <code>foo_bar.cc</code>, 对应于类 <code>FooBar</code>.</p>
<h3 id="73-类型命名">7.3. 类型命名</h3>
<p>类型名称的每个单词首字母均大写, 不包含下划线: <code>MyExcitingClass</code>, <code>MyExcitingEnum</code>.</p>
<p>所有类型命名 —— 类, 结构体, 类型定义 (<code>typedef</code>), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 例如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>// 类和结构体
</span></span><span style="display:flex;"><span>class UrlTable { ...
</span></span><span style="display:flex;"><span>class UrlTableTester { ...
</span></span><span style="display:flex;"><span>struct UrlTableProperties { ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 类型定义
</span></span><span style="display:flex;"><span>typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// using 别名
</span></span><span style="display:flex;"><span>using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 枚举
</span></span><span style="display:flex;"><span>enum UrlTableErrors { ...
</span></span></code></pre></div><h3 id="74-变量命名">7.4. 变量命名</h3>
<p>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: <code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member_</code>.</p>
<p>普通变量命名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>string table_name;  // 好 - 用下划线.
</span></span><span style="display:flex;"><span>string tablename;   // 好 - 全小写.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>string tableName;  // 差 - 混合大小写
</span></span></code></pre></div><p>类数据成员：不管是静态的还是非静态的, 类数据成员都可以和普通变量一样, 但要接下划线.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>class TableInfo {
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span> private:
</span></span><span style="display:flex;"><span>  string table_name_;  // 好 - 后加下划线.
</span></span><span style="display:flex;"><span>  string tablename_;   // 好.
</span></span><span style="display:flex;"><span>  static Pool&lt;TableInfo&gt;* pool_;  // 好.
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>结构体变量：不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样, 不用像类那样接下划线:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>struct UrlTableProperties {
</span></span><span style="display:flex;"><span>  string name;
</span></span><span style="display:flex;"><span>  int num_entries;
</span></span><span style="display:flex;"><span>  static Pool&lt;UrlTableProperties&gt;* pool;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="75-常量命名">7.5. 常量命名</h3>
<p>声明为 <code>constexpr</code> 或 <code>const</code> 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合. 例如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>const int kDaysInAWeek = 7;
</span></span></code></pre></div><h3 id="76-函数命名">7.6. 函数命名</h3>
<p>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: <code>MyExcitingFunction()</code>, <code>MyExcitingMethod()</code>, <code>my_exciting_member_variable()</code>, <code>set_my_exciting_member_variable()</code>.</p>
<p>一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 <code>StartRpc()</code> 而非 <code>StartRPC()</code>).</p>
<p>取值和设值函数的命名与变量一致. 一般来说它们的名称与实际的成员变量对应, 但并不强制要求. 例如 <code>int count()</code> 与 <code>void set_count(int count)</code>.</p>
<h3 id="77-命名空间命名">7.7. 命名空间命名</h3>
<p>命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.</p>
<p>顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.</p>
<h3 id="78-枚举命名">7.8. 枚举命名</h3>
<p>枚举的命名应当和 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#constant-names">常量</a> 或 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#macro-names">宏</a> 一致: <code>kEnumName</code> 或是 <code>ENUM_NAME</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>enum UrlTableErrors {
</span></span><span style="display:flex;"><span>    kOK = 0,
</span></span><span style="display:flex;"><span>    kErrorOutOfMemory,
</span></span><span style="display:flex;"><span>    kErrorMalformedInput,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>enum AlternateUrlTableErrors {
</span></span><span style="display:flex;"><span>    OK = 0,
</span></span><span style="display:flex;"><span>    OUT_OF_MEMORY = 1,
</span></span><span style="display:flex;"><span>    MALFORMED_INPUT = 2,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="8-注释">8. 注释</h1>
<h3 id="81-注释风格">8.1. 注释风格</h3>
<p>使用 <code>//</code> 或 <code>/* */</code>, 统一就好.</p>
<h3 id="82-文件注释">8.2. 文件注释</h3>
<p>法律公告和作者信息：每个文件都应该包含许可证引用. 为项目选择合适的许可证版本.(比如, Apache 2.0, BSD, LGPL, GPL)。如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息.</p>
<p>文件内容：不要在 <code>.h</code> 和 <code>.cc</code> 之间复制注释, 这样的注释偏离了注释的实际意义.</p>
<h3 id="83-类注释">8.3. 类注释</h3>
<p>每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>// Iterates over the contents of a GargantuanTable.
</span></span><span style="display:flex;"><span>// Example:
</span></span><span style="display:flex;"><span>//    GargantuanTableIterator* iter = table-&gt;NewIterator();
</span></span><span style="display:flex;"><span>//    for (iter-&gt;Seek(&#34;foo&#34;); !iter-&gt;done(); iter-&gt;Next()) {
</span></span><span style="display:flex;"><span>//      process(iter-&gt;key(), iter-&gt;value());
</span></span><span style="display:flex;"><span>//    }
</span></span><span style="display:flex;"><span>//    delete iter;
</span></span><span style="display:flex;"><span>class GargantuanTableIterator {
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>类注释应当为读者理解如何使用与何时使用类提供足够的信息, 同时应当提醒读者在正确使用此类时应当考虑的因素. 如果类有任何同步前提, 请用文档说明. 如果该类的实例可被多线程访问, 要特别注意文档说明多线程环境下相关的规则和常量使用.</p>
<p>如果你想用一小段代码演示这个类的基本用法或通常用法, 放在类注释里也非常合适.</p>
<p>如果类的声明和定义分开了(例如分别放在了 <code>.h</code> 和 <code>.cc</code> 文件中), 此时, 描述类用法的注释应当和接口定义放在一起, 描述类的操作和实现的注释应当和实现放在一起.</p>
<h3 id="84-函数注释">8.4. 函数注释</h3>
<p>函数声明处的注释描述函数功能; 定义处的注释描述函数实现.</p>
<p>基本上每个函数声明处前都应当加上注释, 描述函数的功能和用途. 只有在函数的功能简单而明显时才能省略这些注释(例如, 简单的取值和设值函数). 注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情.</p>
<p>函数声明处注释的内容:</p>
<ul>
<li>
<p>函数的输入输出.</p>
</li>
<li>
<p>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.</p>
</li>
<li>
<p>函数是否分配了必须由调用者释放的空间.</p>
</li>
<li>
<p>参数是否可以为空指针.</p>
</li>
<li>
<p>是否存在函数使用上的性能隐患.</p>
</li>
<li>
<p>如果函数是可重入的, 其同步前提是什么?</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>// Returns an iterator for this table.  It is the client&#39;s
</span></span><span style="display:flex;"><span>// responsibility to delete the iterator when it is done with it,
</span></span><span style="display:flex;"><span>// and it must not use the iterator once the GargantuanTable object
</span></span><span style="display:flex;"><span>// on which the iterator was created has been deleted.
</span></span><span style="display:flex;"><span>//
</span></span><span style="display:flex;"><span>// The iterator is initially positioned at the beginning of the table.
</span></span><span style="display:flex;"><span>//
</span></span><span style="display:flex;"><span>// This method is equivalent to:
</span></span><span style="display:flex;"><span>//    Iterator* iter = table-&gt;NewIterator();
</span></span><span style="display:flex;"><span>//    iter-&gt;Seek(&#34;&#34;);
</span></span><span style="display:flex;"><span>//    return iter;
</span></span><span style="display:flex;"><span>// If you are going to immediately seek to another place in the
</span></span><span style="display:flex;"><span>// returned iterator, it will be faster to use NewIterator()
</span></span><span style="display:flex;"><span>// and avoid the extra seek.
</span></span><span style="display:flex;"><span>Iterator* GetIterator() const;
</span></span></code></pre></div><p>注释函数重载时, 注释的重点应该是函数中被重载的部分, 而不是简单的重复被重载的函数的注释. 多数情况下, 函数重载不需要额外的文档, 因此也没有必要加上注释.</p>
<p>注释构造/析构函数时, 切记读代码的人知道构造/析构函数的功能, 所以 “销毁这一对象” 这样的注释是没有意义的. 你应当注明的是注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的.</p>
<p>如果函数的实现过程中用到了很巧妙的方式, 那么在函数定义处应当加上解释性的注释. 例如, 你所使用的编程技巧, 实现的大致步骤, 或解释如此实现的理由. 举个例子, 你可以说明为什么函数的前半部分要加锁而后半部分不需要.</p>
<p><em>不要</em> 从 <code>.h</code> 文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在如何实现上.</p>
<h3 id="85-变量注释">8.5. 变量注释</h3>
<p>通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p>
<p>每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果有非变量的参数(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达, 则应当加上注释. 然而, 如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释.</p>
<p>特别地, 如果变量可以接受 <code>NULL</code> 或 <code>-1</code> 等警戒值, 须加以说明. 比如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>private:
</span></span><span style="display:flex;"><span> // Used to bounds-check table accesses. -1 means
</span></span><span style="display:flex;"><span> // that we don&#39;t yet know how many entries the table has.
</span></span><span style="display:flex;"><span> int num_total_entries_;
</span></span></code></pre></div><p>和数据成员一样, 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因. 比如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>// The total number of tests cases that we run through in this regression test.
</span></span><span style="display:flex;"><span>const int kNumTestCases = 6;
</span></span></code></pre></div><h3 id="86-实现注释">8.6. 实现注释</h3>
<p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p>
<p>行注释：比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>// If we have enough memory, mmap the data portion too.
</span></span><span style="display:flex;"><span>mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());
</span></span><span style="display:flex;"><span>if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))
</span></span><span style="display:flex;"><span>  return;  // Error already logged.
</span></span></code></pre></div><p>如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>DoSomething();                  // Comment here so the comments line up.
</span></span><span style="display:flex;"><span>DoSomethingElseThatIsLonger();  // Two spaces between the code and the comment.
</span></span><span style="display:flex;"><span>{ // One space before comment when opening a new scope is allowed,
</span></span><span style="display:flex;"><span>  // thus the comment lines up with the following comments and code.
</span></span><span style="display:flex;"><span>  DoSomethingElse();  // Two spaces before line comments normally.
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>std::vector&lt;string&gt; list{
</span></span><span style="display:flex;"><span>                    // Comments in braced lists describe the next element...
</span></span><span style="display:flex;"><span>                    &#34;First item&#34;,
</span></span><span style="display:flex;"><span>                    // .. and should be aligned appropriately.
</span></span><span style="display:flex;"><span>&#34;Second item&#34;};
</span></span><span style="display:flex;"><span>DoSomething(); /* For trailing block comments, one space is fine. */
</span></span></code></pre></div><h3 id="87-todo-注释">8.7. TODO 注释</h3>
<p>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 <code>TODO</code> 注释.</p>
<p><code>TODO</code> 注释要使用全大写的字符串 <code>TODO</code>, 在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一 <code>TODO</code> 相关的 issue. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 <code>TODO</code> 格式进行查找. 添加 <code>TODO</code> 注释并不意味着你要自己来修正, 因此当你加上带有姓名的 <code>TODO</code> 时, 一般都是写上自己的名字.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>// TODO(kl@gmail.com): Use a &#34;*&#34; here for concatenation operator.
</span></span><span style="display:flex;"><span>// TODO(Zeke) change this to use relations.
</span></span><span style="display:flex;"><span>// TODO(bug 12345): remove the &#34;Last visitors&#34; feature
</span></span></code></pre></div><p>如果加 <code>TODO</code> 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 “Fix by November 2005”), 或者一个明确的事项 (“Remove this code when all clients can handle XML responses.”).</p>
<h1 id="9-格式">9. 格式</h1>
<h3 id="91-行长度">9.1. 行长度</h3>
<p>每一行代码字符数不超过 80.</p>
<h3 id="92-非-ascii-字符">9.2. 非 ASCII 字符</h3>
<p>尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</p>
<h3 id="93-空格还是制表位">9.3. 空格还是制表位</h3>
<p>只使用空格, 每次缩进 2 个空格.</p>
<p>我们使用空格缩进. 不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格.</p>
<h3 id="94-函数声明与定义">9.4. 函数声明与定义</h3>
<p>返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/#function-calls">函数调用</a> 一致.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
</span></span><span style="display:flex;"><span>  DoSomething();
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
</span></span><span style="display:flex;"><span>                                             Type par_name3) {
</span></span><span style="display:flex;"><span>  DoSomething();
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
</span></span><span style="display:flex;"><span>    Type par_name1,  // 4 space indent
</span></span><span style="display:flex;"><span>    Type par_name2,
</span></span><span style="display:flex;"><span>    Type par_name3) {
</span></span><span style="display:flex;"><span>  DoSomething();  // 2 space indent
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="95-lambda-表达式">9.5. Lambda 表达式</h3>
<p>Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开.</p>
<p>若用引用捕获, 在变量名和 <code>&amp;</code> 之间不留空格.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>int x = 0;
</span></span><span style="display:flex;"><span>auto add_to_x = [&amp;x](int n) { x += n; };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std::set&lt;int&gt; blacklist = {7, 8, 9};
</span></span><span style="display:flex;"><span>std::vector&lt;int&gt; digits = {3, 9, 1, 8, 4, 7, 1};
</span></span><span style="display:flex;"><span>digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;blacklist](int i) {
</span></span><span style="display:flex;"><span>               return blacklist.find(i) != blacklist.end();
</span></span><span style="display:flex;"><span>             }),
</span></span><span style="display:flex;"><span>             digits.end());
</span></span></code></pre></div><h3 id="96-函数调用">9.6. 函数调用</h3>
<p>要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>bool retval = DoSomething(argument1, argument2, argument3);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bool retval = DoSomething(averyveryveryverylongargument1,
</span></span><span style="display:flex;"><span>                          argument2, argument3);
</span></span><span style="display:flex;"><span>if (...) {
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  if (...) {
</span></span><span style="display:flex;"><span>    DoSomething(
</span></span><span style="display:flex;"><span>        argument1, argument2,  // 4 空格缩进
</span></span><span style="display:flex;"><span>        argument3, argument4);
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><h3 id="97-列表初始化格式">9.7. 列表初始化格式</h3>
<p>您平时怎么格式化函数调用, 就怎么格式化 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#braced-initializer-list">列表初始化</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>// 一行列表初始化示范.
</span></span><span style="display:flex;"><span>return {foo, bar};
</span></span><span style="display:flex;"><span>functioncall({foo, bar});
</span></span><span style="display:flex;"><span>pair&lt;int, int&gt; p{foo, bar};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 当不得不断行时.
</span></span><span style="display:flex;"><span>SomeFunction(
</span></span><span style="display:flex;"><span>    {&#34;assume a zero-length name before {&#34;},  // 假设在 { 前有长度为零的名字.
</span></span><span style="display:flex;"><span>    some_other_function_parameter);
</span></span><span style="display:flex;"><span>SomeType variable{
</span></span><span style="display:flex;"><span>    some, other, values,
</span></span><span style="display:flex;"><span>    {&#34;assume a zero-length name before {&#34;},  // 假设在 { 前有长度为零的名字.
</span></span><span style="display:flex;"><span>    SomeOtherType{
</span></span><span style="display:flex;"><span>        &#34;Very long string requiring the surrounding breaks.&#34;,  // 非常长的字符串, 前后都需要断行.
</span></span><span style="display:flex;"><span>        some, other values},
</span></span><span style="display:flex;"><span>    SomeOtherType{&#34;Slightly shorter string&#34;,  // 稍短的字符串.
</span></span><span style="display:flex;"><span>                  some, other, values}};
</span></span><span style="display:flex;"><span>SomeType variable{
</span></span><span style="display:flex;"><span>    &#34;This is too long to fit all in one line&#34;};  // 字符串过长, 因此无法放在同一行.
</span></span><span style="display:flex;"><span>MyType m = {  // 注意了, 您可以在 { 前断行.
</span></span><span style="display:flex;"><span>    superlongvariablename1,
</span></span><span style="display:flex;"><span>    superlongvariablename2,
</span></span><span style="display:flex;"><span>    {short, interior, list},
</span></span><span style="display:flex;"><span>    {interiorwrappinglist,
</span></span><span style="display:flex;"><span>     interiorwrappinglist2}};
</span></span></code></pre></div><h3 id="98-条件语句">9.8. 条件语句</h3>
<p>倾向于不在圆括号内使用空格. 关键字 <code>if</code> 和 <code>else</code> 另起一行.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>if (condition) {  // 圆括号里没有空格.
</span></span><span style="display:flex;"><span>  ...  // 2 空格缩进.
</span></span><span style="display:flex;"><span>} else if (...) {  // else 与 if 的右括号同一行.
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 <code>else</code> 子句时使用:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>if (x == kFoo) return new Foo();
</span></span><span style="display:flex;"><span>if (x == kBar) return new Bar();
</span></span></code></pre></div><h3 id="99-循环和开关选择语句">9.9. 循环和开关选择语句</h3>
<p><code>switch</code> 语句可以使用大括号分段, 以表明 cases 之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用 <code>{}</code> 或 <code>continue</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>switch (var) {
</span></span><span style="display:flex;"><span>  case 0: {  // 2 空格缩进
</span></span><span style="display:flex;"><span>    ...      // 4 空格缩进
</span></span><span style="display:flex;"><span>    break;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  case 1: {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    break;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  default: {
</span></span><span style="display:flex;"><span>    assert(false);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="910-指针和引用表达式">9.10. 指针和引用表达式</h3>
<h3 id="911-布尔表达式">9.11. 布尔表达式</h3>
<p>如果一个布尔表达式超过 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/#line-length">标准行宽</a>, 断行方式要统一一下.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>if (this_one_thing &gt; this_other_thing &amp;&amp;  //逻辑与 (`&amp;&amp;`) 操作符总位于行尾:
</span></span><span style="display:flex;"><span>    a_third_thing == a_fourth_thing &amp;&amp;
</span></span><span style="display:flex;"><span>    yet_another &amp;&amp; last_one) {
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="912-函数返回值">9.12. 函数返回值</h3>
<p>不要在 <code>return</code> 表达式里加上非必须的圆括号.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>return result;                  // 返回值很简单, 没有圆括号.
</span></span><span style="display:flex;"><span>// 可以用圆括号把复杂表达式圈起来, 改善可读性.
</span></span><span style="display:flex;"><span>return (some_long_condition &amp;&amp;
</span></span><span style="display:flex;"><span>        another_condition);
</span></span></code></pre></div><h3 id="913-变量及数组初始化">9.13. 变量及数组初始化</h3>
<p>用 <code>=</code>, <code>()</code> 和 <code>{}</code> 均可.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>int x = 3;
</span></span><span style="display:flex;"><span>int x(3);
</span></span><span style="display:flex;"><span>int x{3};
</span></span><span style="display:flex;"><span>string name(&#34;Some Name&#34;);
</span></span><span style="display:flex;"><span>string name = &#34;Some Name&#34;;
</span></span><span style="display:flex;"><span>string name{&#34;Some Name&#34;};
</span></span></code></pre></div><p>请务必小心列表初始化 <code>{...}</code> 用 <code>std::initializer_list</code> 构造函数初始化出的类型. 非空列表初始化就会优先调用 <code>std::initializer_list</code>, 不过空列表初始化除外, 后者原则上会调用默认构造函数. 为了强制禁用 <code>std::initializer_list</code> 构造函数, 请改用括号.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>vector&lt;int&gt; v(100, 1);  // 内容为 100 个 1 的向量.
</span></span><span style="display:flex;"><span>vector&lt;int&gt; v{100, 1};  // 内容为 100 和 1 的向量.
</span></span></code></pre></div><p>此外, 列表初始化不允许整型类型的四舍五入, 这可以用来避免一些类型上的编程失误.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>int pi(3.14);  // 好 - pi == 3.
</span></span><span style="display:flex;"><span>int pi{3.14};  // 编译错误: 缩窄转换.
</span></span></code></pre></div><h3 id="914-预处理指令">9.14. 预处理指令</h3>
<p>预处理指令不要缩进, 从行首开始.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>// 好 - 指令从行首开始
</span></span><span style="display:flex;"><span>  if (lopsided_score) {
</span></span><span style="display:flex;"><span>#if DISASTER_PENDING      // 正确 - 从行首开始
</span></span><span style="display:flex;"><span>    DropEverything();
</span></span><span style="display:flex;"><span># if NOTIFY               // 非必要 - # 后跟空格
</span></span><span style="display:flex;"><span>    NotifyClient();
</span></span><span style="display:flex;"><span># endif
</span></span><span style="display:flex;"><span>#endif
</span></span><span style="display:flex;"><span>    BackToNormal();
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><h3 id="915-类格式">9.15. 类格式</h3>
<p>访问控制块的声明依次序是 <code>public:</code>, <code>protected:</code>, <code>private:</code>, 每个都缩进 1 个空格.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>class MyClass : public OtherClass {
</span></span><span style="display:flex;"><span> public:      // 注意有一个空格的缩进
</span></span><span style="display:flex;"><span>  MyClass();  // 标准的两空格缩进
</span></span><span style="display:flex;"><span>  explicit MyClass(int var);
</span></span><span style="display:flex;"><span>  ~MyClass() {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  void SomeFunction();
</span></span><span style="display:flex;"><span>  void SomeFunctionThatDoesNothing() {
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  void set_some_var(int var) { some_var_ = var; }
</span></span><span style="display:flex;"><span>  int some_var() const { return some_var_; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> private:
</span></span><span style="display:flex;"><span>  bool SomeInternalFunction();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  int some_var_;
</span></span><span style="display:flex;"><span>  int some_other_var_;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="916-构造函数初始值列表">9.16. 构造函数初始值列表</h3>
<p>构造函数初始化列表放在同一行或按四格缩进并排多行.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>// 如果所有变量能放在同一行:
</span></span><span style="display:flex;"><span>MyClass::MyClass(int var) : some_var_(var) {
</span></span><span style="display:flex;"><span>  DoSomething();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 如果不能放在同一行,
</span></span><span style="display:flex;"><span>// 必须置于冒号后, 并缩进 4 个空格
</span></span><span style="display:flex;"><span>MyClass::MyClass(int var)
</span></span><span style="display:flex;"><span>    : some_var_(var), some_other_var_(var + 1) {
</span></span><span style="display:flex;"><span>  DoSomething();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行
</span></span><span style="display:flex;"><span>// 并逐行对齐
</span></span><span style="display:flex;"><span>MyClass::MyClass(int var)
</span></span><span style="display:flex;"><span>    : some_var_(var),             // 4 space indent
</span></span><span style="display:flex;"><span>      some_other_var_(var + 1) {  // lined up
</span></span><span style="display:flex;"><span>  DoSomething();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 右大括号 } 可以和左大括号 { 放在同一行
</span></span><span style="display:flex;"><span>// 如果这样做合适的话
</span></span><span style="display:flex;"><span>MyClass::MyClass(int var)
</span></span><span style="display:flex;"><span>    : some_var_(var) {}
</span></span></code></pre></div><h3 id="917-命名空间格式化">9.17. 命名空间格式化</h3>
<p>命名空间内容不缩进.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>namespace {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>void foo() {  // 正确. 命名空间内没有额外的缩进.
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}  // namespace
</span></span></code></pre></div><p>声明嵌套命名空间时, 每个命名空间都独立成行.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>namespace foo {
</span></span><span style="display:flex;"><span>namespace bar {
</span></span></code></pre></div><h3 id="918-水平留白">9.18. 水平留白</h3>
<p>水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>void f(bool b) {  // 左大括号前总是有空格.
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>int i = 0;  // 分号前不加空格.
</span></span><span style="display:flex;"><span>// 列表初始化中大括号内的空格是可选的.
</span></span><span style="display:flex;"><span>// 如果加了空格, 那么两边都要加上.
</span></span><span style="display:flex;"><span>int x[] = { 0 };
</span></span><span style="display:flex;"><span>int x[] = {0};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 继承与初始化列表中的冒号前后恒有空格.
</span></span><span style="display:flex;"><span>class Foo : public Bar {
</span></span><span style="display:flex;"><span> public:
</span></span><span style="display:flex;"><span>  // 对于单行函数的实现, 在大括号内加上空格
</span></span><span style="display:flex;"><span>  // 然后是函数实现
</span></span><span style="display:flex;"><span>  Foo(int b) : Bar(), baz_(b) {}  // 大括号里面是空的话, 不加空格.
</span></span><span style="display:flex;"><span>  void Reset() { baz_ = 0; }  // 用空格把大括号与实现分开.
</span></span></code></pre></div><p>循环和条件语句</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>if (b) {          // if 条件语句和循环语句关键字后均有空格.
</span></span><span style="display:flex;"><span>} else {          // else 前后有空格.
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>while (test) {}   // 圆括号内部不紧邻空格.
</span></span><span style="display:flex;"><span>switch (i) {
</span></span><span style="display:flex;"><span>for (int i = 0; i &lt; 5; ++i) {
</span></span><span style="display:flex;"><span>switch ( i ) {    // 循环和条件语句的圆括号里可以与空格紧邻.
</span></span><span style="display:flex;"><span>if ( test ) {     // 圆括号, 但这很少见. 总之要一致.
</span></span><span style="display:flex;"><span>for ( int i = 0; i &lt; 5; ++i ) {
</span></span><span style="display:flex;"><span>for ( ; i &lt; 5 ; ++i) {  // 循环里内 ; 后恒有空格, ;  前可以加个空格.
</span></span><span style="display:flex;"><span>switch (i) {
</span></span><span style="display:flex;"><span>  case 1:         // switch case 的冒号前无空格.
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>  case 2: break;  // 如果冒号有代码, 加个空格.
</span></span></code></pre></div><p>操作符</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>// 赋值运算符前后总是有空格.
</span></span><span style="display:flex;"><span>x = 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.
</span></span><span style="display:flex;"><span>// 圆括号内部没有紧邻空格.
</span></span><span style="display:flex;"><span>v = w * x + y / z;
</span></span><span style="display:flex;"><span>v = w*x + y/z;
</span></span><span style="display:flex;"><span>v = w * (x + z);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 在参数和一元操作符之间不加空格.
</span></span><span style="display:flex;"><span>x = -5;
</span></span><span style="display:flex;"><span>++x;
</span></span><span style="display:flex;"><span>if (x &amp;&amp; !y)
</span></span><span style="display:flex;"><span>  ...
</span></span></code></pre></div><p>模板和转换</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.
</span></span><span style="display:flex;"><span>vector&lt;string&gt; x;
</span></span><span style="display:flex;"><span>y = static_cast&lt;char*&gt;(x);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 在类型与指针操作符之间留空格也可以, 但要保持一致.
</span></span><span style="display:flex;"><span>vector&lt;char *&gt; x;
</span></span></code></pre></div><h3 id="919-垂直留白">9.19. 垂直留白</h3>
<p>垂直留白越少越好.</p>
<p>适当使用垂直留白来划分逻辑段。</p>
</section>

  
  
  <footer class="mt-12 flex flex-wrap">
     
    <a
      class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]"
      href="https://xingkongyj2.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0"
      >读书笔记</a
    >
    
  </footer>
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a
      class="flex w-1/2 items-center rounded-l-md p-6 pr-3 no-underline hover:bg-black/[2%]"
      href="https://xingkongyj2.github.io/post/effective-c&#43;&#43;/"
      ><span class="mr-1.5">←</span><span>Effective C&#43;&#43;</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 no-underline hover:bg-black/[2%]"
      href="https://xingkongyj2.github.io/post/leveldb%E7%AC%94%E8%AE%B0wal/"
      ><span>LevelDB笔记：WAL</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  

  
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2023
    <a class="link" href="https://xingkongyj2.github.io/">YJ-Ma&#39;s blog</a>
  </div>
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >▷ Paper 6</a
  >
</footer>

  </body>
</html>
